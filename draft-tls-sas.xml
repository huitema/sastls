<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY RFC2119 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>

<!ENTITY RFC5246 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml'>

]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<!-- Expand crefs and put them inline -->
<?rfc comments='yes' ?>
<?rfc inline='yes' ?>

<rfc category="std" 
     docName="draft-huitema-tls-sas-00.txt" 
     ipr="trust200902">

<!-- CH: name could just as well be draft-miers-tls-sas-01  -->

<front>
    <title abbrev="SAS for TLS">
      Short Authentication Strings for TLS
    </title>

    <author fullname="Christian Huitema" initials="C." surname="Huitema">
      <organization>Private Octopus Inc.</organization>
      <address>
        <postal>
          <street> </street>
          <city>Friday Harbor</city>
          <code>98250</code>
          <region>WA</region>
          <country>U.S.A.</country>
        </postal>
        <email>huitema@huitema.net</email>
      </address>
    </author>


   <author fullname="Daniel Kaiser" initials="D." surname="Kaiser">
     <organization>University of Konstanz</organization>
      <address>
        <postal>
          <street> </street>
          <city>Konstanz</city>
          <code>78457</code>
          <region></region>
          <country>Germany</country>
        </postal>
        <email>daniel.kaiser@uni-konstanz.de</email>
      </address>
    </author>


    <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
      <organization>Mozilla</organization>
      <address>
        <email>ekr@rtfm.com</email>
      </address>
     </author>  

<!-- CH: need to contact Ian and Matthew, do they want to author a revised draft?	
   Ian Miers
   Johns Hopkins University

   Email:  imiers@cs.jhu.edu

and

   
   Matthew Green
   Johns Hopkins University

   Email:  mgreen@cs.jhu.edu
-->
                                                      
    
    <date year="2017" />                                                                

    <abstract>
        <t> 
   TLS and DTLS connections generally rely on a PKI, a shared secret, or
   endpoint fingerprints for endpoint authentication.  This document
   describes an authentication mechanism which instead generates a
   "short authentication string" (SAS) as an emergent property of the
   connection.  The SAS can then be verified via an external channel in
   order to authenticate the connection.
        </t>
    </abstract>

</front>

<middle>
<section title="Introduction">
<t>
   TLS <xref target="RFC5246" /> and DTLS connections generally rely on a PKI, a shared
   secret, or endpoint fingerprints for endpoint authentication.  This
   document describes an authentication mechanism which instead
   generates a "short authentication string" (SAS) as an emergent
   property of the connection.  The SAS can then be verified via an
   external channel in order to authenticate the connection.
</t>
<t>
   While a fingerprint can be used for authentication (and is used in
   SSH), it is too long to be conveniently read and compared by two
   users.  If a predictable subset of the fingerprint is compared (e.g.,
   the first or last bits) an attacker can create a fingerprint which
   just matches that subset.  The mechanism described by this document
   is based on fingerprints but compares a small number of bits derived
   from the fingerprint and randomness generated by both endpoints, thus
   requiring an attacker to match the entire fingerprint (which is too
   long to be feasible) in order to produce a low probability of
   detection.  In order to compute the SAS, the endpoints run a "coin
   flip" protocol to generate a short shared bitstring which is not
   under the control of either endpoint.  The bitstring is then used,
   along with the TLS fingerprint, to derive a set of bits that are
   mapped to a SAS.
</t>

</section> <!-- Introduction -->

<section title="Terminology">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 <xref target="RFC2119" />.
</t>
</section> <!-- Terminology -->

<section title="Background: Coin-Flipping Protocols">
<t>
   The general pattern of a coin-flipping protocol is shown below:
</t>
<t>
<figure>
<artwork>
           Alice             Bob

           H(R_a) -------------&gt;
           &lt;---------------- R_b
           R_a ----------------&gt;

</artwork>
</figure>
</t>
<t>
   Alice and Bob each generate a large random number R_a and R_b.  Alice
   (who speaks first) computes a commitment to R_a by hashing R_a and
   sends it to Bob. Bob then sends R_b to Alice and finally then Alice
   reveals R_a to Bob. Bob then verifies that R_a matches the hash Alice
   sent in the first message and then each side computes the shared
   value S = R_a XOR R_b.
</t>
</section> <!-- Background: Coin-Flipping Protocols -->

<section title="Protocol Definition">

<section title="Coin Flipping">
<t>
   We map the coin flipping messages to TLS using a TLS extension and a
   new handshake message, as shown below.
</t>

<t>
<figure>
<artwork>
         Client                                               Server

         ClientHello + SASXtn         --------&gt;

                                                ServerHello + SASXtn
                                                        Certificate*
                                                  ServerKeyExchange*
                                                 CertificateRequest*
                                      &lt;--------      ServerHelloDone
         Certificate*
         ClientKeyExchange
         CertificateVerify*
         SASShare
         [ChangeCipherSpec]
         Finished                     --------&gt;             SASShare
                                                  [ChangeCipherSpec]
                                      &lt;--------             Finished
         Application Data             &lt;-------&gt;     Application Data
</artwork>
</figure>
</t>
<t>
   Each side generates a 512-bit cryptographically random value R_client
   and R_server.
</t>
<t>
   The SASXtn is defined as follows:
</t>
<t>
<figure>
<artwork>
             struct {
                 opaque digest&lt;255&gt;;
             } SASExtension;
</artwork>
</figure>
</t>
<t>
   The client's SASXtn is a zero-length value indicating the client's
   desire to do the SAS handshake.  The server's SASXtn is a digest of
   R_server using the Hash defined for the Finished message in Section
   7.4.9 of <xref target="RFC5246" />.
</t>
<t>
   The SASShare structure is defined as follows:
</t>
<t>
<figure>
<artwork>
             struct {
                 opaque share[64];
             } SASShare;
</artwork>
</figure>
</t>
<t>
   "share" is the raw byte value of R_client or R_server, as
   appropriate.
</t>
</section> <!-- Coin Flipping -->

<section title="Computing the raw SAS bits" >
<t>
   The SAS bits are computed as follows:
</t>
<t>
<list style="numbers">
<t>
       If you are the client, verify that the server's R_server matches
       their SASExtension value.  If not, abort the handshake with error
       handshake_failure
</t>
<t>
       Compute R_shared = R_client ^ R_server
</t>
<t>
       If both endpoints have certificate fingerprints compute
       fingerprints=fingerprint_server | fingerprint_client.  If only
       the server has a fingerprint, compute
       fingerprints=fingerprint_server.
</t>
<t>
       Compute SAS_bits as HASH(fingerprints||R_shared) using the Hash
       defined for the Finished message in Section 7.4.9 of <xref target="RFC5246" />
</t>
</list>
</t>
</section> <!-- Computing the raw SAS bits -->

<section title="Computing the SAS String" >
<t>
   The application should map the first 15 &lt; n &lt; len(fingerprints) bits of
   SAS_bits to some set of words or symbols defined for the application.
   One option is the PGP word list.  For a spoken language agnostic
   solution, symbols could be use.

</t>
</section> <!-- Computing the SAS String -->

</section> <!-- Protocol Definition -->

<section title="Security Considerations">
<t>
   Implementations MUST use fresh, random R_client and R_server values
   for each TLS handshake.
</t>
<t>
   Implementations MUST ensure their share of the coin flip remains
   secret until after the TLS session key is established.
</t>
<t>
   Applications SHOULD abort if the SAS strings do not match.
</t>
<t>
   Applications SHOULD abort after multiple failed TLS handshakes and
   notify the user.  Failure to do so will allow an attacker multiple
   attempts to guess a SAS.  They will succeed after a few thousand
   attempts.
</t>
</section> <!-- Security Considerations -->

</middle>

<back>
<references title="Normative References">
   &RFC2119;
   &RFC5246;
</references>
</back>
</rfc>
